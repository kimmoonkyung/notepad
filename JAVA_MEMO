--컴파일
프로그래밍 언어를 기계어로 바꾸어 주는 일
--컴파일러
기계어로 바꾸어 주는 프로그램
자바를 설치하면 자바 컴파일러도 설치 됨.

--실행환경적인 면에서 다른 언어와의 차이점
플랫폼에 독립적인 프로그래밍을 할 수 있음

--자바 프로그램의 특징
객체지향(Object Oriented Programming) 프로그램으로, 유지 보수와 확장성이 좋다.
안정적이다.
풍부한 라이브러리가 제공되고 오픈소스와 연동된다.

--왜 객체 지향 프로그램을 해야 하는가 ?
재사용성이 좋다.
유지보수가 좋다.
코드관리가 용이하다.
신뢰성 높은 프로그램.

--main 함수
실행을 위한 함수

--Java 10 이상 버전
자료형 없이 변수 사용하기
지역 변수 자료형 추론 (local variable type inference)
변수에 대입되는 값을 보고 컴파일러가 추론
ex) 자바스크립트와 같이
    var num = 10;
    var str = "hi";

--변수
변하는 수
사람의 나이, 온라인 상품의 개수, 학생의 학년
변하는 값을 프로그램에서 나타내기 위한 방법

변수 선언하기
    > 자료형 변수 이름;
        > ex) int age;
    변수에 맞는 자료형과 변수 이름으로 선언.

변수와 메모리
변수를 선언하는 것은 해당 자료형의 크기 만큼의 메모리를 사용하겠다는 것
메모리의 위치를 변수 이름으로 참조.

자료형
    > 기본형 : 자바 언어에서 기본적으로 제공해 주는 자료형
               메모리의 크기가 정해져 있음
               정수형, 무낮형, 실수형, 논리형
    > 참조형 : 클래스 자료형
               JDK에서 제공되는 클래스와 프로그래머가 정의하는 클래스
               클래스에 따라 사용하는 크기가 다름

기본자료형
    > 정수형 : byte(1)   표현 범위 > -2의7승 ~ 2의7승-1
               short(2)  표현 범위 > -2의15승 ~ 2의15승-1
               int(4)    표현 범위 > -2의31승 ~ 2의31승-1
               long(8)   표현 범위 > =2의63승 ~ 2의63승-1 [ 식별자는 l 또는 L 사용 ]
    > 문자형 : char(2)
        내부적으로는 비트의 조합으로 표현
            인코딩 - 각 문자에 따른 특정한 숫자 값(코드 값)을 부여
            디코딩 - 숫자 값을 원래의 문자로 변환
        문자세트 : 문자를 위한 코드 값(숫자 값)들을 정해 놓은 세트
        아스키(ASCII) : 1바이트로 영문자, 숫자, 특수문자 등을 표현함
        유니코드 : 한글과 같은 복잡한 언어를 표현하기 위한 표준 인코딩 UTF-8, UTF-16이 대표적
        문자를 변수에 저장하면? 문자에 해당하는 코드 값이 저장 됨.
    > 실수형 : float(4)
               double(8)
        실수는 double 자료형이 기본
        float를 사용 할때는 f 또는 F 식별자 사용
        부동 소수점 방식
            > 실수를 지수부와 가수부로 표현함
        부동 소수점 방식의 오류
            > 지수와 가수로 표현 되는 부동 소수 점은 0을 표현할 수 없음
              따라서 부동 소수점 방식에서는 약간의 오차가 발생할 수 있음
    > 논리형 : boolean(1)

상수와 리터럴
    > 상수(constant) : 변하지 않는 수
    > 리터럴(literal) : 프로그램에서 사용하는 모든 숫자, 값, 논리 값
    모든 리터럴은 상수 풀(constant pool)에 저장되어 있음
    상수 풀에 저장될 때 정수는 int, 실수는 double로 저장 됨

형변환
    서로 다른 자료형의 값이 대입되는 경우 형 변환이 일어남
    묵시적 형 변환(implicit type conversion) : 작은 수에서 큰 수로 
                                               덜 정밀한 수에서 더 정밀한 수로 대입되는 경우
    명시적 형 변환(explicit type conversion) : 변환 되는 자료 형을 명시
                                               자료의 손실이 발생 할 수 있음

-- 2진수, 8진수, 16진수
10을 각 진법으로 쓰면
    2진수 : 0B1010;
    8진수 : 012;
    16진수 : 0XA;
    
항과 연산자
항(operand) : 연산에 사용되는 값
연산자(operator) : 항을 이용하여 연산하는 기호

대입 연산자
int age = 10;
왼쪽 변수의 값이 오른쪽에 대입
우선 순위가 가장 낮은 연산자

부호 연산자
    > 단항 연산자
        변수의 부호를 유지하거나(+) 바꿈(-)
        실제 변수의 값이 변하려면 대입연산자를 사용해야함

산술 연산자
    > % : 나머지 값 
        ex) 5%3 = 1

복합 대입 연산자
대입연산자와 다른 연산자가 함께 쓰임
    ex) int num = 10;
        num += 2;
        > num = 12

증감 연산자
    > 단항 연산자
        변수의 값을 1 더하거나 뺄 때 사용
        연산자가 항의 앞에 있는가 뒤에 있는가에 따라 그 결과가 달라짐
        ex) var = ++num; //먼저 num 값이 1 증가 한 후 val 변수에 대입
            var = num++; //var 변수에 기존 num 값을 먼저 대입한 후 num 값 1 증가

메소드 참조 표현식 ::
람다 표현식에서만 사용 가능하고, [인스턴스]::[메소드명 or new] 로 사용함
    ex) 
    public class DoubleColon {
        public static void main(String[] args) {
            List<String> names = Arrays.asList("노충내", "짐승균");
            names.forEach(x -> System.out.println(x));
            -> 를 아래로 대체 가능하다.
                names.forEach(System.out::println);
        }
    }
    @Override
    public Header<OrderGroupApiResponse> update(Header<OrderGroupApiRequest> request) {

        OrderGroupApiRequest body = request.getData();
        return orderGroupRepository.findById(body.getId())
                .map(orderGroup -> {
                        orderGroup
                                .setRevAddress(body.getRevAddress())
                                ;
                        return orderGroup;
                })
                //.map(newOrderGroup -> orderGroupRepository.save(newOrderGroup)) 이걸 아래와 같이
                .map(orderGroupRepository::save)        // 이런 식으로 사용 가능
                .map(this::response)                    // 이런 식으로 사용 가능
                .orElseGet(() -> Header.ERROR("없데이트!"));
    }

