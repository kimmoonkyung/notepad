--react 설치
설치할 폴더로 이동하여 'create-react-app .'
. 은 현재경로

--샘플 실행
vscode terminal에서 'npm run start'
--종료
vscode terminal에서 'ctrl + c'

--bulid 실행 ( ** 공백 등 같은 불필요한 것들을 제거 하여 용량을 줄인다. -> 실제로 (서비스)배포시 빌드안에 있는 파일을 배포한다. 실서버 환경)
vscode terminal에서  'npm run build'

--npm으로 설치하는 간단한 웹 서버
'npm install -g serve'
-> 어디에서나 serve 명령어로 서버를 설치할 수 있다.
'npx serve -s build'
-> '-s build' 서브라는 웹서버를 받아서 실행시킬때 'build' 라는 생성한 디렉토리를 document 루트로 하겠다. 

--이것은 js 문법이 아니고, jsx 문법이다.
class App extends Component {
  render() {
    return (
      <div className="Subject">
        <Subject></Subject>
     </div>
    )
  }
}

--리액트 코드 작성시
import React, { Component } from 'react';
export default 'JS파일명'
는 필수로 적어야 된다고 생각하면 된다.

--Component 만드는 법.
1. function으로 생성
-> function App() {
    return (
        코드 작성
    )
}
2. class로 생성
-> class App extends Component {
    render() {
        return (
            코드 작성
        )
    }
}


--props
사용자가 컴포넌트를 사용하는 입장에서 중요한것 
function에서는 {this.props.xxx} 사용 안됨
çlass는 사용 가능. function에서는 어떻게 ?

* props are read only
* props can not be modified

--state
데이터를 갖다 쓰는 용도.

* state changes can be asynchronous
* state can be modified using this.setStae({  })
--setState
this.setState({
  mode : "welcome"
})


--key

--bind
.bind(this)

--Immutable
불변.
immutable.js

--router
React Router

--redux


--react server side rendering

------------------------------------------------------------------------------------------------------------------------------------------------------
  > 컴포넌트 이름은 대문자로 시작한다.

-- index.js 와 App.js의 의미


-- JSX 기본 규칙
  > 태그는 꼭 닫혀 있어야 한다.
  > 두개 이상의 태그는 하나로 감싸 있어져야 한다.
    ex) <div></div> <hello/> -> 에러, <div> <div></div> <hello/> </div> 로 해결. 또는 상위 div 대신 <> </>를 사용한다.
  > return 시 괄호는 없어도 된다.
  > jsx 내부에서 js 사용법
    const name = '짐승내'; -> <div>{name}</div>
  > style과 class 설정 방법
    1. style은 객체를 만들어 사용 한다. (속성은 카멜케이스로 작성)
      ex)   const style = {
              backgroundColor: 'rgba(0,0,0, 0.5)',
              color: 'aqua',
              fontSize: 24,
              padding: '1rem'
            };
      <div style={style}></div>
    2. class 는 className 으로 사용한다.
      ex) <div className="hihi"></div>
    3. 주석
      중괄호로 감싸서 사용한다.
      { /*  */ }
      html 코드 내에서는 //로 사용 가능하다.
      ex) <Hello> '// 주석' </Hello>

-- props (proerties 프로퍼티)
컴포넌트를 사용하게 될 때 특정 값의 전달이 필요할 때 사용
  > ex) 
    App.js
      function App() {
        return (
            <Hello name="react" color="aqua"/> --> 이것들이 props 다 name, color
        );
      }
    Hello.js
      /* function Hello(props) { */
      function Hello({color, name}) {
        console.log(props); // {name: react}
        /* return <div style={{color: props.color}}>안녕 나는 짐승내! {props.name} </div>; */
        return <div style={{color}}>안녕 나는 짐승내! {name} </div>;
        // 이런 식으로 사용도 가능하다
      }
    console.log(props);
  
  > defaultProps (기본값) 사용법
    Hello.js
    Hello.defaultProps = {
      name : "짐승균"
    }
    
    App.js
    return (
      <>
        <Hello name="react" color="red" /> name="react"
        <Hello color="black" /> // name="짐승균"으로 기본값이 들어간다.
      </>
    )

  > propsChildren (프롭스 칠드런)
  ex) App.js
      function App() {
        return (
          <Wrapper> ... </Wrapper>
        );
      }  
      Wrapper.js
      function Wrapper({ children }) {
          const style = {
              border: '2px solid black',
              padding: 16
          };
          return (
              <div style={style}>{children}</div>
          )
      }
  > 조건부 렌더링
  {isSpecial && <b>*</b>}

-- useState (동적 상태 관리 - Hooks)
const [number, setNumber] = useState(10); // useState(기본값 설정);
  > Counter.js
    ** import React, { useState } from 'react'; // React 패키지에서 useState 함수를 불러온다.
    function Counter() {
      const [number, setNumber] = useState(0); // useState를 사용하면 배열을 반환하며, 첫번째 원소는 현재 값, 두번째 원소는 값을 변경하는 함수로 사용할 것이다.
      const increase = () => {
        // setNumber(number + 1);
        setNumber(prevNumber => prevNumber + 1); // 함수형 업데이트 (성능 최적화)
      }
      const decrease = () => {
        setNumber(number - 1);
      }
      retrun (
        <div>
          <h1>{number}</h1>
          <button onClick={increase}>+1</button>
          <button onClick={decrease}>-1</button>
        </div>
      )
    }

  > App.js
    function App () {
      return (
        <Counter />
      )
    }

-- useState (input 상태 관리)
  > InputSample.js
    import React, { useState } from 'react';
    function InputSample() {
      const [text, setText] = useState('');
      const onChange = (e) => {
        setText(e.target.value);
      }
      const onReset = () => {
        setText('');
      }
      retrun (
        <div>
          <input onChange={onChange} value={text}/>
          <button onClick={onReset}>초기화</button>
          <b>값 : </b>
          {text}
        </div>
      )
    }

  > 여러개의 input 관리
  function InputSample(){
    const [inputs, setInputs] = useState({
      name : '',
      boyFriend : ''
    });
    const { name, boyFriend } = inputs;
    const onChange = (e) => {
      const {name, value} = e.target;
      setInputs({
        ...inputs,
        [name] : value,
      });
    const onReset = () => {
      setInputs({
        name : '',
        boyFriend : ''
      })
    }
  }
  // 객체 상태를 업데이트 할 때는 ...(스프레드 문법)을 사용해서 객체를 복사하고 난 뒤 상태를 바꿔줘야한다.

-- useRef (특정 DOM 선택하기)
  import React, { useState, useRef } from 'react';
  const nameInput = useRef();
  const onReset = () => {
    setInput({ .. });
    nameInput.current.focus();
  }
  <input ref={nameInput}>
  // 초기화 버튼 클릭시 ref 설정한 input 으로 포커스 이동

-- 배열 렌더링 하기
  function Users( { user } ) {
    return (
      <div>
        <b>{user.name}</b> <span>({user.email})</span>
      </div>
    )
  }
  function UserList() {
    const users = [
      {id : 1, name: '승내', email: '1@mail.com'},
      {id : 2, name: '짐승내', email: '2@mail.com'}
    ]
    return (
      <div>
        { 
          users.map( (user,idx) => (<Users user={user} key={idx}/>) ) 
          // "(user, idx)" 파라미터를 가져와서 "=>" Users 라는 컴포넌트를 렌더링 해줄것("(<Users user={user} />)")
          // idx는 "key={idx}" key props로 사용한다.
            > 미사용 시 child in a list should have a unique "key" prop. > 고유값을 key 로 사용해줘야함.
              > ex) "key={user.id}"
          // key가 없다면 비효율적인 렌더링을 한다.
        }
      </div>
    )
  }

-- useRef 로 컴포넌트 안의 변수 만들기
  컴포넌트가 리렌더링 될 때마다 기억할 수 있는 값을 관리할 때도 사용할 수 있다.
    > ex) setTimeout, setInterval, 외부라이브러리를 사용해서 생성된 인스턴스를 담을때, scroll 위치 등 다양하게 사용한다.
    > useRef로 관리하는 값은 바뀌어도 컴포넌트가 리렌더링 되지 않는다.
  
-- 배열에 항목 추가하기
  // App.js 에서 4개의 props를 받아온다.
  function CreateUser( {username, email, onChange, onCreate} ) {
    > App.js
      <CreateUser username={username} email={email} onChange={onChange} onCreate={onCreate}/>
      > {username}, {email} -> "inputs" 로 관리
        const [inputs, setInputs] = useState({
          username: '',
          email: '',
        });
        const { username, email } = inputs;
      > {onChange} -> "e(이벤트)"를 받아와서 setInputs(useState) 사용. -> name과 value를 e.target에 담음 -> 
        const onChange = (e) => {
          const { name, value } = e.target;
          setInputs({
            ...inputs,
            [name] : value,  // name값을 value로 덮어 씌우겠다. ex) name이 username(input)이면 username의 value 값을,
          });
        };
      > {onCreate} -> 클릭시 "user" 객체 생성 후 setUsers(useState)에 "...users" 로 복사 해온 뒤 생성한 "user" 객체를 더 해주는 로직 -> 이후 setInputs를 통해 inputs들 값을 비워 준다.
                        > 주의 할 점으로 객체를 복사해 올 땐, 기존의 배열을 건들지 않는다. push splice sort 같은 것은 사용 하지 않는다.
        const onCreate = () => {
          const user = {
            id: nextId.current,
            username,
            email, // ...inputs 로 대체 가능
          };
          setUsers([...users, user]); //setUsers(users.concat(user)); 로 대체 가능
          setInputs({
            username: '',
            email : '',
          });
          console.log(nextId.current);
          nextId.current += 1;
        }

-- 배열에 항목 삭제하기
  > App.js
    const onRemove = (id) => {
      console.log("삭제버튼 클릭 : " + id);
      setUsers(users.filter(user => user.id !== id));
    }
    > return()
      <UserList users={users} onRemove={onRemove}/>
  > UserList.js
    > User 컴포넌트
      function User({ user, onRemove }) {
        const {username, email, id} = user;
        > return()
          <button onClick={() => onRemove(id)}>삭제</button>
          {/* <button onClick={onRemove(id)}>삭제</button -> 이렇게 사용하면 렌더링시점에 삭제된다. */}
            > onClick 은 함수를 "() =>" 를 넣어서 사용해야함.

-- 배열에 항목 수정하기
  > App.js
      const onToggle = (id) => {
        console.log("수정버튼 클릭 : " + id);
        setUsers( users.map( user => user.id === id ? { ...user, active: !user.active } : user ) );
        // 파라미터로 가져온 id 값이 일치한다면 active 값을 바꿔준다.
        // "users.map"의 파라미터를 "user"로 사용 하고 user.id의 값과 onToggle을 통해 가져온 id의 값이 일치한다면, 
        // "? { ...user, active: !user.active }" "...user"로 객체를 복사해오고 ",active:" 로 active(boolean 값임.) 값은 반대로 바꿔준다. !user.active
        // ": user" 일치하지 않는다면 기존의 값을 그대로 사용하겠다.
      };
  > UserList.js
    > User 컴포넌트
      function User({ user, onRemove, onToggle }) {
        const {username, email, id, active} = user;
      > return
        <b 
          style={{
            color: active ? 'green' : 'black', // active값이 true 면 "green" false 면 "black"
            cursor: 'pointer'
          }}
          onClick={ () => onToggle(id) }
        >
    > UserList 컴포넌트 onRemove 때와 마찬가지로
      function UserList( {..... onToggle 추가 } )
        > return ()
          <div>
            { users.map( (user) => ( <User user={user} key={user.id} onRemove={onRemove}onToggle={onToggle}/> ) ) }
          </div>

-- useEffect 사용하여 마운트언마운트 업데이트할 작업 설정.
  

-- useMemo
  컴포넌트 최적화시 사용..

-- useCallback
  리렌더링시 컴포넌트 최적화
    > 사용법
      export default React.memo(컴포넌트);

-- useReducer
  // useState -> useReducer 로 변경
  import React, { useReducer } from 'react';
    > reducer 함수 생성
      function reducer(state, action) {
          switch (action.type) {
              case 'INCREMENT' :
                  return state + 1;
              case 'DECREMENT' :
                  return state - 1;
              default:
                  throw new Error('Unhandled action');
          }
      };
    > useState 방식 변경
      const onIncrease = () => {
        setN(prevNumber => prevNumber + 1);
      }
        > useReducer
          const [number, dispatch] = useReducer(reducer, 0);
          const onIncrease = () => {
              dispatch({
                  type : 'INCREMENT'
              })
          }

-- useReducer VS useState
  정해진 답은 없다. 상황에 따라 불편할때도, 편할때도 있다.
  예를들어 컴포넌트에서 관리하는 값이 하나, 혹은 단순한 값 (문자열, boolean, 숫자 등)이면 useState로 관리하는 것이 편할 것이다.
  맘에 드는 방식을 사용 하면 될 것이다.
  간단한거다 싶으면.. useState / 복잡할 것 같다.. 그럼 useReducer

-- custom Hook

-- contextAPI

-- IMMER (개인적으로 맘에든다.)
  불변성 관리
    불변성을 해치는 코드를 작성해도 대신 불변성 유지를 해준다.
  ex ) const arr = [ 
                      { id: 1, text: 'hello'},{ id:2, text: 'bye'},{ id:3, text: '9ood'}
                  ] 
      const nextArr = produce(arr, draft => {
          draft.push({id:4, text: '안녕'});
          draft[0].text = draft[0].text + ' world';
      });
  성능 -> 유의미한 차이가 날정도로 느리다고 볼 순 없는 듯 하다.
          구형 브라우저나 리액트 네이티브 환경에서는 이 기능(proxy)이 지원되지 않는다. -> 느려짐.

-- 클래스형 컴포넌트
  hooks 가 나오기 전까지 함수형 컴포넌트보다 기능이 잘 먹어서 사용함.

-- LifeCycle 메서드
  https://react.vlpt.us/basic/25-lifecycle.html
  https://codesandbox.io/s/hungry-river-5hgu5?file=/src/LifeCycleSample.js:1050-1055

-- 