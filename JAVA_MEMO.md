### 컴파일
    프로그래밍 언어를 기계어로 바꾸어 주는 일
### 컴파일러
    기계어로 바꾸어 주는 프로그램
    자바를 설치하면 자바 컴파일러도 설치 됨.

### 실행환경적인 면에서 다른 언어와의 차이점
    플랫폼에 독립적인 프로그래밍을 할 수 있음

### 자바 프로그램의 특징
    객체지향(Object Oriented Programming) 프로그램으로, 유지 보수와 확장성이 좋다.
    안정적이다.
    풍부한 라이브러리가 제공되고 오픈소스와 연동된다.

### 왜 객체 지향 프로그램을 해야 하는가 ?
1. 재사용성이 좋다.
2. 유지보수가 좋다.
3. 코드관리가 용이하다.
4. 신뢰성 높은 프로그램.

### main 함수
- 실행을 위한 함수

### Java 10 이상 버전
    1. 자료형 없이 변수 사용하기
    2. 지역 변수 자료형 추론 (local variable type inference)
    3. 변수에 대입되는 값을 보고 컴파일러가 추론
        ex) 자바스크립트와 같이
            var num = 10;
            var str = "hi";

### 변수
    변하는 수
    사람의 나이, 온라인 상품의 개수, 학생의 학년
    변하는 값을 프로그램에서 나타내기 위한 방법

### 변수 선언하기
    > 자료형 변수 이름;
        > ex) int age;
    변수에 맞는 자료형과 변수 이름으로 선언.

### 변수와 메모리
    변수를 선언하는 것은 해당 자료형의 크기 만큼의 메모리를 사용하겠다는 것
    메모리의 위치를 변수 이름으로 참조.

### 자료형
1. 기본형 : 자바 언어에서 기본적으로 제공해 주는 자료형
   - 메모리의 크기가 정해져 있음
   - 정수형, 무낮형, 실수형, 논리형
   - 참조형 : 클래스 자료형
        > JDK에서 제공되는 클래스와 프로그래머가 정의하는 클래스. 클래스에 따라 사용하는 크기가 다름
```

```
----------

## 기본자료형
```
정수형 : byte(1)   표현 범위 > -2의7승 ~ 2의7승-1
        short(2)  표현 범위 > -2의15승 ~ 2의15승-1
        int(4)    표현 범위 > -2의31승 ~ 2의31승-1
        long(8)   표현 범위 > =2의63승 ~ 2의63승-1 [ 식별자는 l 또는 L 사용 ]
```
```
문자형 : char(2)
    내부적으로는 비트의 조합으로 표현
        인코딩 - 각 문자에 따른 특정한 숫자 값(코드 값)을 부여
        디코딩 - 숫자 값을 원래의 문자로 변환
    문자세트 : 문자를 위한 코드 값(숫자 값)들을 정해 놓은 세트
    아스키(ASCII) : 1바이트로 영문자, 숫자, 특수문자 등을 표현함
    유니코드 : 한글과 같은 복잡한 언어를 표현하기 위한 표준 인코딩 UTF-8, UTF-16이 대표적
    문자를 변수에 저장하면? 문자에 해당하는 코드 값이 저장 됨.
```
```
실수형 : float(4)
               double(8)
        실수는 double 자료형이 기본
        float를 사용 할때는 f 또는 F 식별자 사용
        부동 소수점 방식
            > 실수를 지수부와 가수부로 표현함
        부동 소수점 방식의 오류
            > 지수와 가수로 표현 되는 부동 소수 점은 0을 표현할 수 없음
              따라서 부동 소수점 방식에서는 약간의 오차가 발생할 수 있음
```
```
논리형 : boolean(1)
```

## 상수와 리터럴
```
상수(constant) : 변하지 않는 수
```
```
리터럴(literal) : 프로그램에서 사용하는 모든 숫자, 값, 논리 값
    모든 리터럴은 상수 풀(constant pool)에 저장되어 있음
    상수 풀에 저장될 때 정수는 int, 실수는 double로 저장 됨
```

### 형변환
```
서로 다른 자료형의 값이 대입되는 경우 형 변환이 일어남
묵시적 형 변환(implicit type conversion) : 작은 수에서 큰 수로 
                                            덜 정밀한 수에서 더 정밀한 수로 대입되는 경우
명시적 형 변환(explicit type conversion) : 변환 되는 자료 형을 명시
                                            자료의 손실이 발생 할 수 있음
```

### 2진수, 8진수, 16진수
> 10을 각 진법으로 쓰면
```
    2진수 : 0B1010;
    8진수 : 012;
    16진수 : 0XA;
```
    
### 항과 연산자
```
항(operand) : 연산에 사용되는 값
연산자(operator) : 항을 이용하여 연산하는 기호
```

### 대입 연산자
```
int age = 10;
왼쪽 변수의 값이 오른쪽에 대입
우선 순위가 가장 낮은 연산자
```

### 부호 연산자

> 단항 연산자
```
    변수의 부호를 유지하거나(+) 바꿈(-)
    실제 변수의 값이 변하려면 대입연산자를 사용해야함
```
> 산술 연산자
```
% : 나머지 값 
ex) 5%3 = 1
```

### 복합 대입 연산자
> 대입연산자와 다른 연산자가 함께 쓰임
```
ex) int num = 10;
        num += 2;
    : num = 12
```

### 증감 연산자
> 단항 연산자
```
변수의 값을 1 더하거나 뺄 때 사용
    연산자가 항의 앞에 있는가 뒤에 있는가에 따라 그 결과가 달라짐
    ex) var = ++num; //먼저 num 값이 1 증가 한 후 val 변수에 대입
        var = num++; //var 변수에 기존 num 값을 먼저 대입한 후 num 값 1 증가
```

## 메소드 참조 표현식 ::
> 람다 표현식에서만 사용 가능하고, [인스턴스]::[메소드명 or new] 로 사용함
```    
예제)
public class DoubleColon {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("노충내", "짐승균");
        names.forEach(x -> System.out.println(x));
        -> 를 아래로 대체 가능하다.
            names.forEach(System.out::println);
    }
}
@Override
public Header<OrderGroupApiResponse> update(Header<OrderGroupApiRequest> request) {

    OrderGroupApiRequest body = request.getData();
    return orderGroupRepository.findById(body.getId())
            .map(orderGroup -> {
                    orderGroup
                            .setRevAddress(body.getRevAddress())
                            ;
                    return orderGroup;
            })
            //.map(newOrderGroup -> orderGroupRepository.save(newOrderGroup)) 이걸 아래와 같이
            .map(orderGroupRepository::save)        // 이런 식으로 사용 가능
            .map(this::response)                    // 이런 식으로 사용 가능
            .orElseGet(() -> Header.ERROR("없데이트!"));
}
```

## 객체의 3가지 요소
> 상태 유지 (객체의 상태)
>
    객체는 상태 정보를 저장하고, 유지되어져야 하며 이러한 속성은 변수로 정의 되어야 함.
    이러한 속성 값이 바뀜으로 인하여 객체의 상태가 변경 될 수 있어야 함.
> 기능 제공 (객체의 책임)
> 
    객체는 기능을 제공해야 함. 이 부분은 메소드의 제공으로 이루어진다.
    이 부분은 캡슐화와 연관이 있으며, 외부로부터 직접 속성에 접근하여 변경하는 것이 아닌 객체가 제공하는 메소드로 기능이 제공되어져야 함.
> 고유 식별자 제공 (객체의 유일성)
> 
    각각의 객체는 고유한 식별자를 가져야 함.
    예를 들면 카드번호, 계좌번호, 자동차 번호와 같은 속성을 통해서 각각 고유한 값을 줄 수 있으며
    이는 이후 DB에서 Unique Key, 또는 Primary key로도 작성이 가능.

## 물리 객체와 개념 객체
> 물리객체
```
물리적 객체는 실제로 사물이 존재하며, 이를 클래스로 정의한 객체를 의미.
    ex) 자동차 렌탈 시스템: 자동차, 고객, 직원, 사업장, 정비소 등등이 객체
        급여 관리 시스템 : 직원, 월급통장 등이 객체
        카드사 시스템 : 카드, 직원 등
```
> 개념 객체
```
우리가 개발 할 웹 시스템에서 Service에 해당되며, 이는 Business Logic을 처리하는 부분을 의미.
Business Logic에서는 여러 객체를 서로 상호작용 하도록 하며, 객체가 제공하는 오퍼레이션 method를 통하여 객체의 속성을 변경 시킴.
    ex) 1. 사용자 관리 시스템 
            사용자 객체의 마지막 접속일자를 이용하여, 계정만료, 삐밀번호 초기화, 재등록 처리 등
        2. ATM 시스템
            사용자(Object)의 Action에 따라, 계좌(Object)의 잔고의 속성을 변경하는(입금/출금) Logic 처리
```
```
객체지향에서의 코딩은 각 객체에 기능을 정의하고 이를 business logic을 처리하는 Service에서 객체의 메소드를 활용하여 여러가지 조건을 확인 한 뒤 객체의 속성을 변경하는 작업이 주
```

## 캡슐화
> 메소드 설계
- 속성이 선언되었으나, 이의 상태를 변경하는 메소드가 없다면 잘못 선언 된 속성이다.
    즉, 자신이 가지고 있는 속성에 대해서는 해당 상태를 변경하는 기능을 제공해야 함.
- 실물 객체가 가진 기능을 모두 제공해야 함.
    예를 들면 자동차의 렌탈, 반납, 주행거리 계산 등
- 각각의 메소드는 서로 관련성이 있어야 함.
    차량의 렌탈/반납, 자동차 등록증 등록/해지 등 각 속성의 상대되는 기능을 제공해야 함.
- 객체 안의 메소드는 객체 안의 속성을 처리해야 하며, 다른 객체를 전달 받아 해당 다른 객체에 정의 된 속성을 직접 처리하면 안 된다.

> 단, 메소드에 실행에 필요한 값들은 객체의 형태가 아닌 매개변수의 형태로 전달되어져야 함.
    
- 객체의 영구성 관리 메소드
    영구성(유효성) 속성에 대한 변경이 필요한 경우 외부에서는 접근이 불가능 하도록 private로 선언하며 내부의 다른 메소드를 통해서 사용 되도록 함.
----------
```

```

# 객체 지향 설계 5원칙 SOLID
> 응집도와 결합도 
> 
*좋은 소프트웨어 설계를 위해서는 결합도(coupling)는 낮추고 응집도(cohesion)는 높인다.*

1. *결합도*
> 
```결합도
모듈(클래스)간의 상호 의존 정도를 나타내는 지표로써
결합도가 낮으면 모듈간의 상호 의존성이 줄어 들어서 객체의 재사용 및 유지보수가 유리함.
```
2. *응집도*
>
```응집도
하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로
응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져, 재사용 및 유지보수가 유리함.            
```
----------

```객체 지향 설계 5원칙 SOLID 
1. SRP(Single Responsibility Principle) 단일 책임 원칙
    어떠한 클래스를 변경해야 하는 이유는 한가지 뿐이여야 함.
2. OCP(Open Closed Principle) 개방 폐쇄 원칙
    자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 함.
    상위 클래스 또는 인터페이스를 중간에 둠으로써, 자신의 변화에 대해서는 폐쇄적이지만,
    인터페이스는 외부의 변화에 대해서 확장을 개방해 줄 수 있다.
    이러한 부분은 JDBC와 MyBatis, Hibernate 등 JAVA에서는 Stream(Input, Out)에서 찾아볼 수 있따.
3. LSP (Liskov Substitution Principle) 리스코프 치환 원칙
    서브 타입은 언제나 자신의 기반(상위) 타입으로 교체 할 수 있어야 한다.
4. ISP (Interface Segregation Principle) 인터페이스 분리 원칙
    클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다.
    프로젝트 요구 사항과 설계에 따라서 SRP(단일책임원칙) / ISP(인터페이스분리원칙)를 선택 한다.
5. DIP (Dependency Inversion Principle) 의존 역전 원칙
    자신보다 변하기 쉬운 것에 의존하지 말아야 한다.
        ex) 사람은 옷에 의존하지만 옷은 계절마다 변함.
            > 사람 -> 옷 <- 여름옷/봄옷/가을옷
SOLID는 객체지향 4대 특성에 기반하기 때문에 유사한 모양을 가지고 있음.
```

## POJO JAVA
```
POJO (Plain Old Java Objcect)
    순수한 자바 오브젝트를 뜻 함.
        특징
            1. 특정 규약에 종속 되지 않는다.
                특정 Library, Module 에서 정의 된 클래스를 상속 받아서 구현하지 않아도 됨.
                POJO가 되기 위해서는 외부의 의존성을 두지 않고, 순수한 JAVA로 구성이 가능해야 함.
            2. 특정 환경에 종속 되지 않는다.
                만일 특정 비즈니스 로직을 처리하는 부분에 외부 종속적인 http request, session 등이 들어가면 
                    POJO를 위배한 것으로 간주.
                또한 많이 사용하고 있는 @Annotation 설정도 엄연히 POJO라고 볼 수는 없다.
```